#!/usr/bin/python
#
#   "Ubproxy"
#   with GTK Interface 
#
#   Ubuntu and derivatives proxy setting tool.
#   This sets the apt,bash and profile config-files.
#
#   An inevitable tool to configure proxy-settings in universities and office environmment.
#   Eliminates the need of repetitive editing of system files that is prone to frequent manual errors.  
#   Atleast 3 different individual config files needs to be edited to configure proxy settings,
#   This can be used in an environment where all the Three - ("http","https" and the "ftp") proxies
#   have the same settings.
#
#
#   Author:
#
#   E-mail:
#
#   Date:
#
#   Profile:
#
#   Forked from  https://code.google.com/p/ubproxy/
#
# Changelog:
# >  GTK support enabled
# >  Removed profile saving option
#


import gtk
import os
import subprocess
import re
import sys
from datetime import datetime
from pwd import getpwnam

filenames = ["/etc/bash.bashrc", "/etc/environment"]
filename2 = "/etc/apt/apt.conf"
logs = "/var/log/proxychangerlog"

gsettingsUser = 'user'
gsettingsResetMode = 'none'


## https://askubuntu.com/a/484752
def prepare_gsettings():
    #pid = subprocess.check_output(["pgrep", "gnome-session"]).decode("utf-8").strip(A)
    pid = subprocess.check_output(["pgrep", "xfce4-session"]).decode("utf-8").strip()
    #cmd = "grep -z DBUS_SESSION_BUS_ADDRESS /proc/"+pid+"/environ|cut -d= -f2-"
    cmd = "grep -z DBUS_SESSION_BUS_ADDRESS /proc/"+pid+"/environ  |  cut -d= -f2-  |  sed -r 's/(.+)/DBUS_SESSION_BUS_ADDRESS=\\\\1/'"
    #print ("PATH: < %s >" % (os.environ["PATH"]))
    #print ("DBUS_SESSION_BUS_ADDRESS: < %s >" % (os.environ["DBUS_SESSION_BUS_ADDRESS"]))
    os.environ["DBUS_SESSION_BUS_ADDRESS"] = subprocess.check_output(['/bin/bash', '-c', cmd]).decode("utf-8").strip().replace("\0", "")
    #os.environ["DBUS_SESSION_BUS_ADDRESS"] = 'unix:abstract=/tmp/dbus-3LpGWPt0WX,guid=c17a8bf032ed6179687fa8265f215de7' 


class Sub:
    def __init__(self, base):
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("Authorization")
        self.vbox = gtk.VBox()
        self.hbox0 = gtk.HBox()
        self.hbox1 = gtk.HBox()
        self.hbox2 = gtk.HBox()
        self.label1 = gtk.Label("Username")
        self.label2 = gtk.Label("Password")
        self.entry1 = gtk.Entry()
        self.entry2 = gtk.Entry()
        self.entry2.set_visibility(False)
        self.but1 = gtk.Button("Ok")
        self.but2 = gtk.Button("Cancel")

        self.hbox0.pack_start(self.label1)
        self.hbox0.pack_start(self.entry1)
        self.hbox1.pack_start(self.label2)
        self.hbox1.pack_start(self.entry2)
        self.hbox2.pack_start(self.but1)
        self.hbox2.pack_start(self.but2)

        self.vbox.pack_start(self.hbox0)
        self.vbox.pack_start(self.hbox1)
        self.vbox.pack_start(self.hbox2)
        self.label1.show()
        self.label2.show()
        self.entry1.show()
        self.entry2.show()
        self.but1.show()
        self.but2.show()
        self.hbox0.show()
        self.hbox1.show()
        self.hbox2.show()
        self.vbox.show()
        self.window.add(self.vbox)
        self.window.show()
        self.but2.connect("clicked", self.cancel, base.checkbox)
        self.but2.connect_object("clicked", gtk.Widget.destroy, self.window)
        self.but1.connect("clicked", self.ok, base)
        self.but1.connect_object("clicked", gtk.Widget.destroy, self.window)

    def ok(self, event, data=None):
        data.uname = self.entry1.get_text()
        data.passw = self.entry2.get_text()

    def cancel(self, event, data=None):
        data.set_active(False)

    def delete_event(self, widget, event, data=None):
        return True


class Base:
    def __init__(self):

        self.checkbox = gtk.CheckButton("Authentication?")
        self.box0 = gtk.VBox()
        self.box1 = gtk.HBox()
        self.box2 = gtk.VBox()

        self.box3 = gtk.HBox()
        self.box4 = gtk.HBox()
        self.box5 = gtk.HBox()

        self.entry = gtk.Entry()
        self.box0.pack_start(self.box2)
        self.box0.pack_start(self.checkbox)
        self.box0.pack_start(self.box1)
        self.box2.pack_start(self.box3)
        self.entry.show()
        self.button1 = gtk.Button("Set")
        self.button2 = gtk.Button("Remove")
        self.box1.pack_start(self.button1)
        self.box1.pack_start(self.button2)

        self.label1 = gtk.Label("Host")
        self.label2 = gtk.Label("Port")
        self.label3 = gtk.Label("httpsProtocol")

        self.button1.show()
        self.button2.show()
        self.entry2 = gtk.Entry()
        self.entry3 = gtk.Entry()
        self.entry3.set_text("http")
        #self.flog.write("httpsProtocol display default: < %s >\n" % (self.entry3.get_text()))
        self.box2.pack_start(self.box4)
        self.box2.pack_start(self.box5)

        self.entry.connect("activate", self.act, self.entry)
        self.entry2.connect("activate", self.act, self.entry2)
        self.entry3.connect("activate", self.act, self.entry3)

        self.checkbox.connect("toggled", self.tog, None)

        self.box3.pack_start(self.label1)
        self.box3.pack_start(self.entry)
        self.box4.pack_start(self.label2)
        self.box4.pack_start(self.entry2)
        self.box5.pack_start(self.label3)
        self.box5.pack_start(self.entry3)

        self.entry2.show()
        self.entry3.show()
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.add(self.box0)
        self.label1.show()
        self.label2.show()
        self.label3.show()
        self.box2.show()
        self.box1.show()
        self.box0.show()
        self.box3.show()
        self.box4.show()
        self.box5.show()
        self.checkbox.show()
        #
        # before show--
        #
        self.window.show()
        self.window.set_title("Ubproxy")
        self.opentext()
        self.button1.connect("clicked", self.set, None)
        self.button2.connect("clicked", self.remove, None)
        self.button1.connect_object("clicked", gtk.Widget.destroy, self.window)
        self.button2.connect_object("clicked", gtk.Widget.destroy, self.window)
        self.window.connect("destroy", self.destroy)

    def destroy(self, widget, data=None):
        if (self.flog != None):
            self.flog.close()
        gtk.main_quit()
        sys.exit(0)

    def act(self, widget, data=None):
        print data.get_text()

    def fin(self):
        self.host = self.entry.get_text()
        self.port = self.entry2.get_text()
        self.httpsProtocol = self.entry3.get_text()
        self.flog.write("httpsProtocol finally: < %s >\n" % (self.httpsProtocol))
        self.auth = self.checkbox.get_active()

    def tog(self, widget, data=None):
        if (widget.get_active()):
            sub = Sub(self)

    def set(self, widget, data=None):
        self.backup([filenames[0], filenames[1], filename2])
        self.flog.write("Files have been backed up in '~/.Ubuntu-Proxy/'  with .backup extension \n")
        self.clean(filename2, filenames)
        self.fin()
        if self.host != "":
            self.setup(     self.host, self.port,  (self.uname if self.auth else ""),  (self.passw if self.auth else "") )
        self.gsettings_upd( self.host, self.port,  (self.uname if self.auth else ""),  (self.passw if self.auth else "") )
        self.mbx = gtk.MessageDialog(self.window, gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CLOSE,
                                     "SUCCESSFULLY " + ("SET" if self.host != "" else "REMOVED"))
        self.mbx.run()
        self.mbx.destroy()

    def delete_event(self, widget, event, data=None):
        return False

    def remove(self, widget, data=None):
        self.backup([filenames[0], filenames[1], filename2])
        self.flog.write("Files have been backed up in '~/.Ubuntu-Proxy/' with .backup extension \n")
        self.clean(filename2, filenames)
        self.flog.write("Old Proxy-Settings removed \n")
        self.mbx = gtk.MessageDialog(self.window, gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CLOSE,
                                     "SUCCESSFULLY REMOVED")
        self.mbx.run()
        self.mbx.destroy()

    def opentext(self):
        try:
            self.flog = open(logs, "a")
            self.flog.write(str(datetime.now()) + "\n")
        except:
            self.flog = None
            md = gtk.MessageDialog(self.window, gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_CLOSE,
                                   "You are not a Root user --Run This as 'sudo'")
            md.run()
            md.destroy()
            sys.exit(0)


    ## on "https" it may be "http" or "https" depending on your env
    ## otherwise it returns <typ> as is
    def protoForTyp(self, typ):
        return self.httpsProtocol if typ == "https" else typ


    ## e.g. < export https_proxy="http://myusr:mypass@myhost:8080" >
    ## e.g. < export https_proxy="https://myusr:mypass@myhost:8080" >
    ## e.g. < HTTP_PROXY="http://myhost:8080" >
    def declConstruct(self, upperOn, typ, bashOn, protoTyp, srv, port, name, pasw):
        s = "export " if bashOn else ""
        v = "%s_proxy" % (typ)
        s += v.upper() if upperOn else v
        s += "=\"%s://" % (protoTyp)
        if name != "":  s += "%s:%s@" % (name, pasw)
        return s + "%s:%s\"" % (srv, port)


    def setup(self, srv, port, name, pasw):

        ## filenames (terminal env)

        lin = []
        typ0 = ("http", "ftp", "https")
        for filenam in filenames:
            fil = open(filenam, "a")
            for x in typ0:
                self.flog.write("setup: file=< %s >,  protocTyp=< %s >,  name:***@srv:port= < %s:***@%s:%s >,  httpsProtocol=< %s >  (emtpy name will be ignored => no auth)\n" % (filenam, x, name, srv, port, self.httpsProtocol))
                lin.append( self.declConstruct(  False,  x,  (filenam.find("bash") != -1),  self.protoForTyp(x), srv, port, name, pasw  ) + "\n")
                lin.append( self.declConstruct(  True,   x,  (filenam.find("bash") != -1),  self.protoForTyp(x), srv, port, name, pasw  ) + "\n")
                #if (filenam.find("bash") != -1):
                #    if name == "": lin.append("export %s_proxy=\"%s://%s:%s\"\n"       % (x, protoForTyp(x), srv, port))
                #    else:          lin.append("export %s_proxy=\"%s://%s:%s@%s:%s\"\n" % (x, protoForTyp(x), name, pasw, srv, port))
                #else:
                #    if name == "": lin.append("%s_proxy=\"%s://%s:%s\"\n"              % (x, protoForTyp(x), srv, port))
                #    else:          lin.append("%s_proxy=\"%s://%s:%s@%s:%s\"\n"        % (x, protoForTyp(x), name, pasw, srv, port))
            for l in lin:
                fil.write(l)
            fil.close()
            lin = []
    
        ## filename2 (apt.conf)

        lin = []
        fil = open(filename2, "w")
        for x in typ0:
            self.flog.write("setup: file=< %s >,  protocTyp=< %s >,  name:***@srv:port= < %s:***@%s:%s >,  httpsProtocol=< %s >  (emtpy name will be ignored => no auth)\n" % (filename2, x, name, srv, port, self.httpsProtocol))
            if name == "": lin.append('Acquire::%s::proxy "%s://%s:%s/";\n' % (x, self.protoForTyp(x), srv, port))
            else:          lin.append('Acquire::%s::proxy "%s://%s:%s@%s:%s/";\n' % (x, self.protoForTyp(x), name, pasw, srv, port))
        for l in lin:
            fil.write(l)
        fil.close()


    def backup(self, *files):
        homefol = os.getenv('HOME')
        folder = homefol + "/.Ubuntu-Proxy/"
        try:
    
            os.mkdir(folder)
        except:
            pass

        filstr = datetime.now().strftime('%Y%h%d_%H%M%S')
        newfolder = folder + filstr + "/"
        try:
            os.mkdir(newfolder)
        except:
            pass

        for fil in files:
            try:
                f1 = open(fil, "r")
                l = f1.read()
                f1.close()

                if (fil.find(".") == -1):
                    newname = fil[fil.rfind('/') + 1:] + ".backup"


                else:
                    fil = fil[fil.rfind('/') + 1:]
                    newname = fil[:fil.find(".")] + ".backup"
                newname = newfolder + newname
                f2 = open(newname, "w")
                f2.write(l)
                f2.close()
            except:
                pass


    #def clean(self, file2, *files, para=False):
    def clean(self, file2, files): 
        para=False

        if (para):
            for file1 in files:
                try:
                    self.flog.write("clean: file=< %s >\n" % (file1))
                    f = open(file1, 'r')
                    l = f.read()
                    l = re.sub(r'\n?(.*http_proxy\s*=\s*".*")', r'\n# \g<1>', l, flags=re.I)
                    l = re.sub(r'\n?(.*https_proxy\s*=\s*".*")', r'\n# \g<1>', l, flags=re.I)
                    l = re.sub(r'\n?(.*ftp_proxy\s*=\s*".*")', r'\n# \g<1>', l, flags=re.I)
                    f.close()
                    f = open(file1, 'w')
                    f.write(l)
                    f.close()
                except:

                    pass
        else:
            for file1 in files:
                try:
                    self.flog.write("clean: file=< %s >\n" % (file1))
                    f = open(file1, 'r')
                    l = f.read()
                    l = re.sub(r'\n?(.*http_proxy\s*=\s*".*")', r'', l, flags=re.I)
                    l = re.sub(r'\n?(.*https_proxy\s*=\s*".*")', r'', l, flags=re.I)
                    l = re.sub(r'\n?(.*ftp_proxy\s*=\s*".*")', r'', l, flags=re.I)
                    f.close()
                    f = open(file1, 'w')
                    f.write(l)
                    f.close()
                except:
    
                    pass
            try:
                self.flog.write("clean: file=< %s >\n" % (file2))
                f = open(file2, "r")
                l = f.read()
                l = re.sub(r'\n?(.*Acquire.*".*?";)', "", l)
                f.close()
                f = open(file2, 'w')
                f.write(l)
                f.close()
            except:
    
                pass

    def gsettings_upd(self, srv, port, name, pasw):
        self.flog.write("gsettings_upd: protocTyp=< http for all >,  name:***@srv:port= < %s:***@%s:%s >  (emtpy name will be ignored => no auth)\n" % (name, srv, port))

        #prepare_gsettings()

        uid = getpwnam( gsettingsUser )[2]
        os.setgid( uid )
        os.setuid( uid )
        #def setuidfunc():
        #    os.setgid(uid)
        #    os.setuid(uid)
        #os.system("gsettings set org.gnome.system.proxy.http enabled false")
        #subprocess.check_output('/bin/bash -c "gsettings set org.gnome.system.proxy mode \'auto\'"', preexec_fn=setuidfunc)

        if srv == '':
                os.system("gsettings set org.gnome.system.proxy mode '%s'" % (gsettingsResetMode))
                #os.system("gsettings set org.gnome.system.proxy.http enabled false")
                #subprocess.check_output('/bin/bash -c "gsettings set org.gnome.system.proxy mode \'auto\'"', preexec_fn=setuidfunc)
                return

        os.system("gsettings set org.gnome.system.proxy mode 'manual'")
        os.system("gsettings set org.gnome.system.proxy.http enabled true")
        os.system("gsettings set org.gnome.system.proxy.http host '%s'" % (srv))
        os.system("gsettings set org.gnome.system.proxy.http port '%s'" % (port))
        os.system("gsettings set org.gnome.system.proxy.ftp host '%s'" % (srv))
        os.system("gsettings set org.gnome.system.proxy.ftp port '%s'" % (port))
        ## this seems not possible to apply:
        #if self.httpsProtocol == "https":
        #    os.system("gsettings set org.gnome.system.proxy.https host '%s'" % (srv))
        #    os.system("gsettings set org.gnome.system.proxy.https port '%s'" % ())
        if name != "":
            os.system("gsettings set org.gnome.system.proxy.http authentication-user '%s'" % (name))
            os.system("gsettings set org.gnome.system.proxy.http authentication-password '%s'" % (pasw))
        else:
            os.system("gsettings set org.gnome.system.proxy.http use-authentication false")


      
if __name__ == "__main__":
    if not os.geteuid() == 0:
        args = ['gksudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('gksudo', *args)
    base = Base()
    gtk.main()
